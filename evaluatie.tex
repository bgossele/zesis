\chapter{Evaluatie}

\section{Functionele vereisten: testing}

Onze implementatie van GEMINI in combinatie met Cassandra ondersteunt de belangrijkste features van GEMINI (zie \ref{gemini_beschrijving}), op een paar uitzonderingen na:
\begin{itemize}
\item Inladen genoominformatie: GEMINI met Cassandra ondersteunt dezelfde input (i.e. VCF-, PED-, en annotatiefiles) als GEMINI met SQLite. Enkel door de gebruiker zelf gedefinieerde annotatiebestanden zijn nog niet ondersteund, maar dit is perfect analoog met de voorgedefinieerde bestanden en werd slechts uit tijdgebrek niet ge\"implementeerd.
\item Querying van genoominformatie: GEMINI met Cassandra behoudt de query-functionaliteit van de SQLite-implementatie, inclusief de uitgebreide SQL-syntax zoals genotype-filters en -wildcards, sample-wildcards. De enige soort queries die onze implementatie niet biedt, zijn pure range-queries, zoals:

\texttt{SELECT * FROM variants WHERE start > 123456}

Zoals eerder beschreven in \ref{cassandra_datamodel} laat het datamodel van Cassandra dit niet toe: het is op basis van de query onmogelijk een primary key te bepalen van de rijen in het resultaat om zo een set opeenvolgende rijen uit de tabel in kwestie op te vragen.
\item Voorts biedt GEMINI nog vele andere tools voor zeer specifieke genetische onderzoeksdoeleinden. We hebben die niet nader bestudeerd, maar gezien ze allen voortbouwen op de queryfunctionaliteit, hebben we de basis er wel voor gelegd.
\end{itemize}

Dankzij de uitgebreide verzameling unit-tests van GEMINI hebben we de laad- en queryfunctionaliteiten ook grondig kunnen testen en het correct functioneren van onze implementatie kunnen bewijzen.

\section{Niet-functionele vereisten: benchmarking}

Gezien onze implementatie de gewenste functionaliteit biedt, rest nog de vraag of ze ook, zoals beoogd, beter schaalt naar grote genoomdatasets. Om dit te evalueren hebben we onze versie van GEMINI onderworpen aan een reeks benchmarkingtests en vervolgens de executietijd van zowel het inladen als doorzoeken van genoominformatie met GEMINI gemeten. Ter vergelijking hebben we ook de prestaties van de SQLite-versie van GEMINI gemeten voor dezelfde tests.

\subsection{Testomgeving}

Voor de experimenten gebruikten we de publiek beschikbare genoomdata van het 1000 Genome project \cite{10002012integrated}. Die datasets bevatten enkel de VCF-files, niet de sample-informatie van de proefpersonen. Om toch de hele featureset te kunnen testen, hebben we willekeurig een geslacht en fenotype aan de samples toegekend. Specifiek hebben we 5 verschillende VCF-files (in reeds gezipte toestand, vandaar de bestandsextensie) gebruikt:
\begin{itemize}
\item \texttt{s\_1092.vcf.gz} van 1.8 GB met 494328 variants van 1092 samples.
\item \texttt{m\_1092.vcf.gz} van 3.0 GB met 855166 variants van 1092 samples.
\item \texttt{l\_1092.vcf.gz} van 6.7 GB met 1882663 variants van 1092 samples.
\item \texttt{xl\_1092.vcf.gz} van 11.8 GB met 3307592 variants van 1092 samples.
\item \texttt{s\_2504.vcf.gz} van 1.2 GB met 7081600 variants van 2504 samples.
\end{itemize}

De experimenten hebben we uitgevoerd op het cluster van het lab, bestaande uit nodes met elk 2 Intel X5660-processoren (6 cores, 12 threads, dus 12 cores en 24 threads per node), 96 GB RAM en 500 GB schijfruimte. GEMINI met SQLite draaide steeds in zijn geheel op 1 zo'n node, GEMINI met Cassandra hebben we afhankelijk van experiment tot experiment op 1 of 2 nodes uitgevoerd, met daarnaast een Cassandra-cluster dat draaide op 3 tot 10 nodes, weer afhankelijk van het experiment.

\subsection*{Structuur}

In de volgende paragraaf zullen we \'e\'en voor \'e\'en de experimenten en hun resultaten bespreken, te beginnen met de performantietesten van het inladen van gegevens, en vervolgens de queries. We zullen daarbij deze structuur hanteren:
\begin{enumerate}
\item Opzet van het experiment. Wat meet het experiment precies?
\item Omstandigheden: precieze input, commando, gebruikte infrastructuur.
\item Resultaten
\item Reflectie
\end{enumerate}

\subsection{Experiment 1: \texttt{gemini load} met Cassandra vs. SQLite}
\label{exp1}
\subsection{Experiment 2: Schaalbaarheid \texttt{gemini load} met grootte Cassandra-cluster}
\label{exp2}
\subsection{Experiment 3: \texttt{gemini query} met Cassandra vs. SQLite}
\label{exp3}

\subsubsection{Opzet}
Het doel van dit experiment is de executietijd van verschillende relevante queries in GEMINI te vergelijken van de Cassandra- en SQLite-implementaties. Daarvoor hebben we 7 queries geselecteerd die de volledige queryingfunctionaliteit van GEMINI bestrijken en bovendien representatief zijn voor de queries die biologen in GEMINI uitvoeren. De gebruikte queries zijn gebaseerd op de documentatie van GEMINI en hun relevantie is afgetoetst bij onze contactpersoon bij Janssen Pharmaceutica.

\subsubsection{Omstandigheden}

We hebben de runtime van onderstaande 7 queries gemeten op de \texttt{s\_1092.vcf}- en \texttt{m\_1092.vcf}-datasets, enerzijds op een Cassandra-cluster met 9 nodes en replicatiefactor 3 en anderzijds in SQLite. Onze implementatie van GEMINI hebben we alle 24 beschikbare threads op \'e\'en node laten gebruiken. Voor de Cassandra-versie van GEMINI hebben we zowel gemeten hoe lang het uitvoeren van de subqueries als het totale proces duurt, voor de SQLite-versie enkel de totale duur.

\begin{enumerate}
\item \textbf{Query 1} Deze query dient om de performantie van eenvoudige queries op de kolommen van een tabel zoals de \texttt{variants}-tabel te meten.

\begin{adjustwidth}{-1.0in}{}
\lstinputlisting[language=sh,firstline=1,lastline=3]{gemini_src/benchmarking_queries.sh}
\end{adjustwidth}

\item \textbf{Query 2} Deze query dient ook om de performantie van eenvoudige queries op de kolommen van de \texttt{variants}-tabel te meten.

\begin{adjustwidth}{-1.0in}{}
\lstinputlisting[language=sh,firstline=25,lastline=28]{gemini_src/benchmarking_queries.sh}
\end{adjustwidth}

\item \textbf{Query 3} Deze query dient om de performantie van een eenvoudige genotype-filter te meten, met de disjuncte combinatie van voorwaarden op het genotype van 2 proefpersonen.

\begin{adjustwidth}{-1.0in}{}
\lstinputlisting[language=sh,firstline=5,lastline=6]{gemini_src/benchmarking_queries.sh}
\end{adjustwidth}

\item \textbf{Query 4} Deze query dient om de performantie van een eenvoudige genotype-filter te meten, met de conjuncte combinatie van voorwaarden op het genotype van 2 proefpersonen.

\begin{adjustwidth}{-1.0in}{}
\lstinputlisting[language=sh,firstline=8,lastline=9]{gemini_src/benchmarking_queries.sh}
\end{adjustwidth}

\item \textbf{Query 5} Deze query dient om de performantie van een eenvoudige genotype-filter te meten, met de negatie van een voorwaarde op het genotype van 1 sample.

\begin{adjustwidth}{-1.0in}{}
\lstinputlisting[language=sh,firstline=11,lastline=12]{gemini_src/benchmarking_queries.sh}
\end{adjustwidth}

\item \textbf{Query 6} Deze query dient om de performantie van een eenvoudige genotype-wildcard te meten, die alle variants zoekt waarvoor alle geaffecteerde (fenotype = 2) samples niet homozygoot voor het referentie-allel zijn.

\begin{adjustwidth}{-1.0in}{}
\lstinputlisting[language=sh,firstline=14,lastline=15]{gemini_src/benchmarking_queries.sh}
\end{adjustwidth}

\item \textbf{Query 7} Deze query dient om de performantie van een combinatie van genotype-wildcards te meten, die alle variants zoekt waarvoor alle geaffecteerde (fenotype = 2) samples wel homozygoot voor het referentie-allel zijn en bovendien de depth van de variant call voldoende hoog is.

\begin{adjustwidth}{-1.0in}{}
\lstinputlisting[language=sh,firstline=17,lastline=19]{gemini_src/benchmarking_queries.sh}
\end{adjustwidth}

\item \textbf{Query 8} Deze query dient om de performantie van een combinatie van genotype-wildcards te meten, die alle variants zoekt waarvoor alle geaffecteerde (fenotype = 2) samples niet homozygoot voor het referentie-allel zijn en bovendien de depth van de variant call voor maximum 9 samples lager dan 20 is. Het is een minder restricitieve versie van query 7.

\begin{adjustwidth}{-1.0in}{}
\lstinputlisting[language=sh,firstline=21,lastline=23]{gemini_src/benchmarking_queries.sh}
\end{adjustwidth}

\end{enumerate}

\newpage
\subsubsection{Resultaten}

\begin{table}[h]

\begin{tabular}{@{}lllll@{}}
\cmidrule(l){3-5}
                              &         & \multicolumn{2}{|l|}{\textbf{Cassandra}}                                                      & \multicolumn{1}{l|}{\textbf{SQLite}}                             \\ 
\cmidrule(l){2-5}
\multicolumn{1}{l|}{}  & \multicolumn{1}{l|}{\textbf{\# Resultaten}}               & \multicolumn{1}{l|}{\textbf{Subqueries [s]}} & \multicolumn{1}{l|}{\textbf{Totaal [s]}} & \multicolumn{1}{l|}{\textbf{Totaal [s]}} \\ \midrule
\multicolumn{1}{|l|}{\textbf{Query 1}} & \multicolumn{1}{l|}{339819} & \multicolumn{1}{l|}{$6.34 \pm 0.13$}             & \multicolumn{1}{l|}{$443.46 \pm 6.85$}          & \multicolumn{1}{l|}{$148.4 \pm 1.06$}                          \\
\multicolumn{1}{|l|}{\textbf{Query 2}} & \multicolumn{1}{l|}{15588} & \multicolumn{1}{l|}{$1.62 \pm 0.38$}             & \multicolumn{1}{l|}{$40.37 \pm 2.40$}          & \multicolumn{1}{l|}{$2.53 \pm 0.02$}                          \\
\multicolumn{1}{|l|}{\textbf{Query 3}} & \multicolumn{1}{l|}{447392} &\multicolumn{1}{l|}{$8.75 \pm 0.07$}            & \multicolumn{1}{l|}{$573.85 \pm 3.78$}          & \multicolumn{1}{l|}{$8428.81 \pm 30.31$}                        \\
\multicolumn{1}{|l|}{\textbf{Query 4}} & \multicolumn{1}{l|}{15218} &\multicolumn{1}{l|}{$8.74 \pm 0.10$}            & \multicolumn{1}{l|}{$43.19 \pm 1.20$}            & \multicolumn{1}{l|}{$8412.17 \pm 36.02$}                        \\
\multicolumn{1}{|l|}{\textbf{Query 5}} & \multicolumn{1}{l|}{463148} &\multicolumn{1}{l|}{$1.90 \pm 0.06$}            & \multicolumn{1}{l|}{$593.12 \pm 5.09$}           & \multicolumn{1}{l|}{$8405.53 \pm 29.26$}                        \\
\multicolumn{1}{|l|}{\textbf{Query 6}} & \multicolumn{1}{l|}{9645} &\multicolumn{1}{l|}{$13.85 \pm 0.15$}                 & \multicolumn{1}{l|}{$41.73 \pm 0.90$}                    & \multicolumn{1}{l|}{$8404.66 \pm 24.28$}                        \\
\multicolumn{1}{|l|}{\textbf{Query 7}} & \multicolumn{1}{l|}{0} &\multicolumn{1}{l|}{$15.27 \pm 0.53$}          & \multicolumn{1}{l|}{$15.28 \pm 0.53$}           & \multicolumn{1}{l|}{$8513.17 \pm 132.52$}                        \\
\multicolumn{1}{|l|}{\textbf{Query 8}} & \multicolumn{1}{l|}{9536} &\multicolumn{1}{l|}{$34.18 \pm 0.34$} & \multicolumn{1}{l|}{$64.57 \pm 2.91$}       & \multicolumn{1}{l|}{$8448.35 \pm 19.25$}                                \\ 
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Reflectie}

Uit het resultaat voor query 1 en 2 blijkt dat GEMINI met Cassandra voor eenvoudige queries op de \texttt{variants}-tabel het grootste deel van de totale executietijd besteed aan het ophalen van het finale resultaat. GEMINI met SQLite moet hiervoor niet over het netwerk communiceren en is duidelijk sneller.\\
Queries 3, 4 en 5 tonen dat de evaluatie van genotype-filters in GEMINI met Cassandra grootordes sneller verloopt dan met SQLite: ongeacht de grootte van het resultaat zal SQLite \'e\'en voor \'e\'en alle variants overlopen, de binaire genotype-kolommen decomprimeren en de filter als een Python-\texttt{eval}-statement evalueren. GEMINI met Cassandra komt ervan af met een beperkt aantal (gelijk aan het aantal clausules in de filter) subqueries die elk slechts een subset van het totale variants teruggeven, en moet enkel de resultaten hiervan nog combineren. De totale kost hangt hier duidelijk samen met de kardinaliteit van het resultaat, waar die in het SQLite afhangt van het totale aantal variants.\\
Queries 6, 7 en 8 tonen dat ook de evaluatie van genotype wildcards significant sneller verloopt met een Cassandra-database dan met een SQLite-database. Het evalueren van de subqueries duurt bij deze queries duidelijk langer dan in de eenvoudige genotype-filters van queries 4 \& 5, maar het zijn er dan ook beduidend meer. Er zijn {\color{red} ?} samples met fenotype 2, wat betekent dat elke wildcard zich vertaalt naar {\color{red} ?} subqueries. \\
Het verschil in uitvoeringstijd tussen query 7 en 8 kan verklaard worden door de kardinaliteit van het resultaat van het linkerlid van de respectievelijke conjuncties: het linkerlid van query 7 geeft 0 variants terug, waardoor de evaluatie van het rechterlid overgeslagen kan worden. Het linkerlid van query 8 daarentegen, levert {\color{red} ?} variants op, waardoor het rechterlid wel ge\"evalueerd dient te worden. Dit kost opnieuw {\color{red} ?} subqueries.

\subsection{Experiment 4: Schaalbaarheid \texttt{gemini query} bij parallellisatie GEMINI}
\label{exp4}

\subsubsection{Opzet}

Het doel van dit experiment is te onderzoeken of de querysnelheid meeschaalt wanneer GEMINI geparallelliseerd wordt over meerdere threads. We bestuderen het effect van parallellisatie bij zowel het ophalen van het finale resultaat van queries als bij het evalueren van subqueries van genotype-wildcards.

\subsubsection{Omstandigheden}

Voor dit experiment hebben we query 1 en 7 uit experiment 3 (\ref{exp3}) hergebruikt: query 1 omwille van de grootte van het resultaat, query 7 omwille van de duur van de evaluatie van de genotype wildcard. We hebben de uitvoeringstijd voor de twee queries gemeten bij uitvoering van GEMINI met 4, 8, 12, 16 en 24 threads. Het Cassandra-cluster bestond uit 9 nodes, met replicatiefactor 3.

\subsubsection{Resultaten}

\begin{table}[!h]

\begin{tabular}{@{}lllll@{}}
\cmidrule(l){2-5}
                                       & \multicolumn{2}{|l|}{\textbf{Query 1}}                                                      & \multicolumn{2}{l|}{\textbf{Query 8}}                             \\ 
\midrule
\multicolumn{1}{|l|}{\textbf{\# Threads}}  & \multicolumn{1}{l|}{\textbf{Subqueries [s]}}               & \multicolumn{1}{l|}{\textbf{Totaal [s]}} & \multicolumn{1}{l|}{\textbf{Subqueries [s]}} & \multicolumn{1}{l|}{\textbf{Totaal [s]}} \\ \midrule
\multicolumn{1}{|l|}{\textbf{4}} & \multicolumn{1}{l|}{$6.32 \pm 0.07$} & \multicolumn{1}{l|}{$1850.51 \pm 60.21$}             & \multicolumn{1}{l|}{$84.31 \pm 1.72$}          & \multicolumn{1}{l|}{$145.18 \pm 3.46$}                        \\
\multicolumn{1}{|l|}{\textbf{8}} & \multicolumn{1}{l|}{$6.22 \pm 0.05$} &\multicolumn{1}{l|}{$949.67 \pm 1.95$}            & \multicolumn{1}{l|}{$63.40 \pm 0.37$}          & \multicolumn{1}{l|}{$102.99 \pm 2.21$}                        \\
\multicolumn{1}{|l|}{\textbf{12}} & \multicolumn{1}{l|}{$6.21 \pm 0.09$} &\multicolumn{1}{l|}{$679.06 \pm 3.37$}            & \multicolumn{1}{l|}{$49.16 \pm 0.31$}           & \multicolumn{1}{l|}{$81.00 \pm 1.32$}                        \\
\multicolumn{1}{|l|}{\textbf{16}} & \multicolumn{1}{l|}{$6.25 \pm 0.07$} &\multicolumn{1}{l|}{$562.33 \pm 6.50$}                 & \multicolumn{1}{l|}{$49.81 \pm 0.21$}                    & \multicolumn{1}{l|}{$78.32 \pm 0.72$}                        \\
\multicolumn{1}{|l|}{\textbf{24}} & \multicolumn{1}{l|}{$6.34 \pm 0.13$} &\multicolumn{1}{l|}{$443.46 \pm 6.85$}          & \multicolumn{1}{l|}{$34.18 \pm 0.34$}           & \multicolumn{1}{l|}{$64.57 \pm 2.91$}                        \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Reflectie}

Uit de resultaten voor query 1 blijkt dat de runtime van eenvoudige queries met een resultaat met hoge kardinaliteit lineair afneemt met het aantal gebruikte threads. Gezien de evaluatie van de subqueries (in dit geval slechts 1) niet geparallelliseerd wordt, is er hierin weinig verschil te merken. Het verschil in de totale executietijd is dus volledig toe te schrijven aan verhoogde doorvoer bij het opvragen van de resultaten. Bij query 8 is er ook een duidelijke daling van de executietijd merkbaar, doch niet zo sterk als bij query 1. Dit wijst er duidelijk op dat queries in onze implementatie eerder I/O-bound dan CPU-bound zijn.

\subsection{Experiment 5: Schaalbaarheid \texttt{gemini query} met grootte Cassandra-cluster}
\label{exp5}

